import sys
sys.stdin = open('input.txt', 'r')

# 비트 연산자 사용

T = int(input())    # 테스트 케이스의 수 T
E = 12  # 원소의 개수 E

# 1부터 12까지의 숫자를 원소로 가진 집합 A
# 집합 A의 부분 집합 중 N개의 원소를 갖고 있고, 원소의 합이 K.

# list로 이루어진 2차원 배열과 목표 숫자 K 매개변수로 받고,
# list의 원소들의 합 k일때, cnt한다
# cnt를 return

for test_case in range(1, 1+T):
    N, K = map(int, input().split())
    # print(N, K)

    # 부분 집합 중 N개의 원소를 가진 집합들 다 정렬.
    # 그 집합들 각각의 원소들의 합이 K와 같은 부분집합 개수 cnt
    # 해당하는 부분집합 없는 경우 0 출력

    list_A = [1, 12, 10, 11, 5, 6, 3, 4, 7, 8, 2, 9]    # 일부러 순서 뒤죽박죽으로 해보자
    ans = 0
    for i in range(1 << E):     # E(=12)개의 원소를 가지는 집합의 부분집합의 개수, 2^E와 같다.
        sum_of_elements = 0  # 부분집합 원소들의 합 초기화
        cnt = 0  # 부분집합의 원소의 개수 cnt 초기화
        '''
        "하나의 반복마다 하나의 부분집합이다."
        i는 0, 1, 2, ... 2**E-1
        for i .... 로 만드는 반복은
            부분집합이 어떤 원소를 가지고 있는지는 모르지만, 
            일단 총 2^E개는 분명하니까 각 부분집합마다 반복.
        '''
        for j in range(E):      # 모집합 원소의 개수 E의 길이만큼 비트 비교 반복
            '''
            여기서는 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}가 모집합이다.
            이걸 집합말고 list처럼 index가 있다고 생각해보자.
            
            어떤 부분집합에서 만약 index = 0, 1, 3의 원소만 '존재한다면'
            그 부분집합은 {1, 2, 4}일 것이다.
            여기서 
            원소가 '존재할 때' 비트가 '1',
            원소가 '없을 때' 비트가 '0'으로 나타낸다면,
            각 부분집합들은 12개의 비트(1과0)로 이루어졌다고 볼 수 있다.
            
            그렇다면 우리가 처음 생각한 부분집합의 총 개수 2^12 와 같다!
            0, 1, 2, 3.. 2^12 이것들을 2진수로 나타내면 결국 비트로 나타내는 것과 같고.
            0~ 2^12 까지 모든 수는 당연하게도
            "비트들이 서로 다르다."
            비트들이 같다면, 그건 같은 수니까.
            예를 들어 2진수에서 
                0b0010 과 0b0100은 서로 다른 수다.
                당연하다! 그래야 수를 셀 수 있으니까
            이걸 마치 비트가 1인 부분은 원소가 존재하고, 비트가 0인 부분은 원소가 존재하지 않는다고 생각하면
            모든 부분집합들의 종류를 나타낼 수 있다.
            
            그렇다면 어떤 부분집합에서 비트가 1인 index를 구한 뒤, 
            그 index를 원소들의 list에 대입하면 
            그 부분집합이 어떤 원소를 지니는지 알 수 있다!
            '''
            if i & (1 << j):   # i의 j번 비트가 1인 경우
                '''
                자 여기서 ( 1 << j )는 그냥 2^j와 같다고 했었다.
                그러면 j는 for j in range(E)로 도니까
                1, 2, 3, ..., E 이다.
                그러면 결국 2^j 를 for로 돌리면 
                for로 j가 하나씩 늘어날 때마다
                이진법에서 왼쪽으로 한 칸 씩 미는 것과 같다. 
                
                즉, j번 자리의 비트가 i와 같은지 확인하는데,
                이걸 i는 고정하고 (바깥쪽 for문이니까) j를 계속 이진법에서 한 칸씩 왼쪽으로 밀면서 확인하는 것과 같다.
                근데 i는 뭐라고했지?
                i는 1, 2, 3... 2^12라고 했다.
                그리고 이 각각의 수들은 이진수로 나타낼 수 있다.
                그리고 이진수로 나타냈을때, 모두 비트들의 종류가 다르고,
                이 종류가 다른 비트들 중 비트가 1인 위치를 확인하면
                그 i가 어떤 원소들로 이루어진 부분집합을 '나타내는지' 알 수 있다.
                
                결국 i = 1,2,3...2^12 를 이진수로 나타냈을 때
                원소가 12개인 집합의 모든 부분집합의 '개수'와 일대일 대응이 되고.
                그 i들의 비트에서 1인 위치를 index해서 모집합에 대응하면
                그 부분집합의 원소들을 알 수 있다.
                
                원래 모집합은 집합이라 순서가 뒤죽박죽일 수 있지만 상관없다.
                어차피 한 부분집합 안의 원소들의 순서도 상관없고, 
                부분집합들 간의 순서도 상관없으니까
                
                !! 이진법으로 수를 나타낼 때 
                    0b0101 이라면
                    0*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 5
                    이렇게 계산할때는 비트의 순서가 당연히 중요하다.
                    이거랑 헷갈리지 말자. 
                !!
                
                '''
                # sum_of_elements += 2 ** j     이러면 틀리는거다. j는 이진법이 아니라 '비트'다.

                sum_of_elements += list_A[j]    # 만약 있다면, 그 값을 합에 추가
                cnt += 1                        # 부분집합 원소 개수 확인용 cnt +=1, 비트가 1이다 == 원소가 그 자리에 있다.

        if sum_of_elements == K and cnt == N:    # 문제의 두 조건을 모두 만족한다면, 출력값에 + 1
            ans += 1

    print(f'#{test_case} {ans}')





